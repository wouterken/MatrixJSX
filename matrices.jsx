function sel(){    return app.selection[0];}function idmatrix(){    return sel().transformValuesOf(CoordinateSpaces.PASTEBOARD_COORDINATES )[0];}function matrix(){        return arguments[0].transformValuesOf(CoordinateSpaces.PASTEBOARD_COORDINATES )[0].matrixValues;}function trace(){    $.writeln.apply($, arguments);}function selectionMatrix(){        return new matrix3d(matrix(sel()));}function applyMatrix3d(item, m3){    trace(toIDMatrix(m3).matrixValues);    item.transform(CoordinateSpaces.pasteboardCoordinates, item.resolve([0,0], CoordinateSpaces.INNER_COORDINATES) , toIDMatrix(m3));}function toIDMatrix(m3){        var p = m3.points;        return app.transformationMatrices.add(undefined, undefined, undefined, undefined, undefined, undefined, [p[0][0],p[0][1],p[1][0],p[1][1],p[0][2],p[1][2]]);}function matrix3d(m2){                this.points = [[1,0,0],[0,1,0],[0,0,1]];        this.points[0][0] = m2[0];        this.points[0][1] = m2[1];        this.points[1][0] = m2[2];        this.points[1][1] = m2[3];        this.points[0][2] = m2[4];        this.points[1][2] = m2[5];              this.determinant = function(){           var p = this.points;           return (p[0][0] * p[1][1] * p[2][2] + p[0][1] * p[1][2] * p[2][0]  + p[0][2] * p[1][0] * p[2][1]) - (p[0][2] * p[1][1] * p[2][0] + p[0][1] * p[1][0] * p[2][2]  + p[0][0] * p[1][2] * p[2][1]);        }            this.cofactor = function(){                var p = this.points;                var result = [[],[],[]];                var det = function(r1,r2){                      return r1[0] * r2[1] - (r2[0]) * (r1[1]);                }                result[0][0] = det([p[1][1], p[1][2]], [p[2][1],p[2][2]]);                result[0][1] = -det([p[1][0], p[1][2]], [p[2][0],p[2][2]]);                result[0][2] = det([p[1][0], p[1][1]], [p[2][0],p[2][1]]);                result[1][0] = -det([p[0][1], p[0][2]], [p[2][1],p[2][2]]);                result[1][1] = det([p[0][0], p[0][2]], [p[2][0],p[2][2]]);                result[1][2] = -det([p[0][0], p[0][1]], [p[2][0],p[2][1]]);                result[2][0] = det([p[0][1], p[0][2]], [p[1][1],p[1][2]]);                result[2][1] = -det([p[0][0], p[0][2]], [p[1][0],p[1][2]]);                result[2][2] = det([p[0][0], p[0][1]], [p[1][0],p[1][1]]);                return tom3d(result);        }            this.adjugate = function(){                var co = this.cofactor().points;                var result = [[],[],[]];                for(var i = 0; i < 3; i++){                        for(var j = 0; j < 3; j++){                                result[j][i] = co[i][j];                        }                }                return tom3d(result);        }        this.translate = function(x, y){              var rot = tom3d([                [1, 0, x],                [0, 1, y],                [0, 0, 1]]);              var result = rot * this;              this.points = result.points;        }        this.inverse = function(){            var co = this.adjugate();            var c = co.points;            var d = this.determinant();            return tom3d([                    [c[0][0]/d, c[0][1]/d, c[0][2]/d],                    [c[1][0]/d, c[1][1]/d, c[1][2]/d],                    [c[2][0]/d, c[2][1]/d, c[2][2]/d]                ]);        }            this["*"] = function(m3){             var p1 = this.points;             var p2 = m3.points;             var result = [[],[],[]];             result[0][0] = p1[0][0] * p2[0][0] + p1[0][1] * p2[1][0] + p1[0][2] * p2[2][0];             result[0][1] = p1[0][0] * p2[0][1] + p1[0][1] * p2[1][1] + p1[0][2] * p2[2][1];             result[0][2] = p1[0][0] * p2[0][2] + p1[0][1] * p2[1][2] + p1[0][2] * p2[2][2];             result[1][0] = p1[1][0] * p2[0][0] + p1[1][1] * p2[1][0] + p1[1][2] * p2[2][0];             result[1][1] = p1[1][0] * p2[0][1] + p1[1][1] * p2[1][1] + p1[1][2] * p2[2][1];             result[1][2] = p1[1][0] * p2[0][2] + p1[1][1] * p2[1][2] + p1[1][2] * p2[2][2];             result[2][0] = p1[2][0] * p2[0][0] + p1[2][1] * p2[1][0] + p1[2][2] * p2[2][0];             result[2][1] = p1[2][0] * p2[0][1] + p1[2][1] * p2[1][1] + p1[2][2] * p2[2][1];             result[2][2] = p1[2][0] * p2[0][2] + p1[2][1] * p2[1][2] + p1[2][2] * p2[2][2];             return tom3d(result);        }        this.scale = function(x, y){             var result = tom3d(                [[x, 0, 0],                [0, y, 0],                [0, 0, 1]]) * this;              this.points = result.points;                        }                this.rotate = function(delta){              delta = delta/(180/Math.PI)              var rot = tom3d(                [[Math.cos(delta), -Math.sin(delta), 0],                [Math.sin(delta), Math.cos(delta), 0],                [0, 0, 1]]);              var result = this * rot;              this.points = result.points;        }}function printPoints(points){        for(var i = 0; i < points.length; i++){                var point = points[i];                trace("["+point+"]");        }}function getPoints(poly){        var allPoints = Array.prototype.concat.apply([], poly.paths.everyItem().entirePath);        var pairs = [];        for(var i = 0; i < allPoints.length; i+= 2){                pairs.push(allPoints[i], allPoints[i+1]);        }        return pairs;}function identity(){        return tom3d([            [1,0,0],            [0,1,0],            [0,0,1]]        );}function tom3d(points){        var m = new matrix3d([1,0,0,1,0,0]);        m.points = points;        return m;}function printMatrix(m3){        var value = "";        for(var i = 0; i < m3.points.length; i++){                var row = m3.points[i];                value += "["+row+"]\n";       }       trace(value);}var i = identity();i.rotate(-90);i.translate(-35, -35);trace(idmatrix().counterclockwiseRotationAngle);applyMatrix3d (sel(), i)