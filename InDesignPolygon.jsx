function Poly(state, color, normal){    if(state && 'id' in state && document.pageItems.itemByID(state.id).isValid){          this.shape = state;          this.vectors = this.getVectorsFromShape();          try{          color = this.shape.fillColor.colorValue          }catch(err){}    }else{          this.vectors = state;          this.shape = this.getShapeFromVectors();    }    this.pathVectors = this.vectors.slice(0);        this.normal = normal || new Vector3D(0, 0, -1);    this.baseNormal = this.normal;    this.matrix = new Matrix3D([1,0,0],[0,1,0],[0,0,1]);    if(color)        color.length == 3?this.setColor(color[0], color[1], color[2]):this.setColor(color[0], color[1], color[2], color[3]);    else        this.setColor(0,0,0);}Poly.prototype.setColor = function(r, g, b, k){        this.color = col(r,g,b, k);        this.shape.fillColor = this.color;}function col(r,g,b, k){        if(k !== undefined){            var name = "C="+r+" M="+g+" Y="+b+" K="+k;            var col = document.colors.itemByName(name);            if(col.isValid){                    return col;            }else{                var col =col = document.colors.add({name:name, space:ColorSpace.CMYK, colorValue:[r,g,b,k]});                return col;            }        }else{            var name = "R="+r+" G="+g+" B="+b;            var col = document.colors.itemByName(name);            if(col.isValid){                    return col;            }else{                var col =col = document.colors.add({name:name, space:ColorSpace.RGB, colorValue:[r,g,b]});                return col;            }        }}Poly.prototype.toObject3D = function(depth){    if(depth){        return new Object3D(this.get3DPolys(depth));    }else{        return new Object3D([this]);    }}Poly.prototype.get3DPolys = function(depth){    var backfaceVecs = this.vectors.slice(0);    for(var j = 0; j < backfaceVecs.length; j++){         backfaceVecs[j] = backfaceVecs[j].slice(0);         var bfs = backfaceVecs[j];         for(var i = 0; i < bfs.length; i++){              if(bfs[i] instanceof Array){                  bfs[i] = bfs[i].slice(0);                  for(var vi=0; vi < bfs[i].length; vi++){                        bfs[i][vi] = bfs[i][vi].clone();                   }              }else{                    bfs[i] = bfs[i].clone();              }         }     }        var backface = new Poly(backfaceVecs, this.color.colorValue, new Vector3D(0, 0, 1));        for(var j = 0; j < backface.vectors.length; j++){        var bf = backface.vectors[j];        bf.reverse();        for(var i = 0; i < bf.length; i++){            var vec = bf[i];            if(vec instanceof Array){                    vec[0].setZ(vec[0].z + depth);                    vec[1].setZ(vec[1].z + depth);                    vec[2].setZ(vec[2].z + depth);                    var temp = vec[0];                    vec[0] = vec[2];                    vec[2] = temp;            }else{                vec.setZ(vec.z + depth);            }        }    }    return [this, backface].concat(this.getSidePolys(depth));}Poly.prototype.getSidePolys = function(depth){        var polys = [];        var paths = this.shape.paths.everyItem().getElements();        var p1, p2;                for(var pIdx = 0; pIdx < paths.length; pIdx++){            var path = paths[pIdx];            var points = path.entirePath;            var first = null            p1 = null;            for(var i = 0; i < points.length; i++){                var point = points[i];                var vec;                if(point.length == 3){                        vec = [                            Vector3D(point[0][0], point[0][1],1),                            Vector3D(point[1][0], point[1][1],1),                            Vector3D(point[2][0], point[2][1],1)                        ];                }else{                       vec = Vector3D(point[0], point[1], 1);                }                var temp = p1;                p2 = vec;                if(temp){                    polys.push(this.getPoints(p1, p2, depth));                }                p1 = p2;                first = first || p1;            }            polys.push(this.getPoints(p2, first, depth));        }        return polys;}Poly.prototype.duplicateVectorArray = function(vec){    var ret;    if(vec instanceof Array){        ret = vec.slice();        for(var i = 0; i < ret.length; i++){                ret[i] = ret[i].clone();        }    }else{        ret = vec.clone();    }    return ret;}Poly.prototype.getPoints = function(vec1, vec2, depth){                var p3 = this.duplicateVectorArray(vec2)        var p4 = this.duplicateVectorArray(vec1)        var doubles = [p3,p4];        for(var pIdx = 0; pIdx < doubles.length; pIdx++){              var point = doubles[pIdx];              if(point instanceof Array){                    point[0].setZ(point[0].z + depth);                    point[1].setZ(point[1].z + depth);                    point[2].setZ(point[2].z + depth);              }else{                  point.setZ(point.z + depth);              }        }        var ap = this.asSimplePoints;        var pointsArray = [].concat(ap(p4, true), ap(p3, false), ap(vec2, false, false), ap(vec1, false, false));        normalPoly = new Poly([[p4, p3, vec2, vec1]]);        var shapeNormal = normalPoly.calculateNormal();        normalPoly.shape.remove();        var p = new Poly([pointsArray]);        p.baseNormal = shapeNormal        return p;    }Poly.prototype.asSimplePoints = function (vec1, begin, special){        if(vec1 instanceof Array){            var p1 = vec1[0];            var p2 = vec1[1];            var p3 = vec1[2];            if(begin){                return [[p1.clone(),p1.clone(),p1.clone()], [p1,p2,p3]];            }            else{                return [[p1,p2,p3], [p1.clone(),p1.clone(),p1.clone()]];            }        }else{                return [vec1];        }}Poly.prototype.getVectorsFromShape = function(){        var paths = this.shape.paths.everyItem().getElements();        var Vectors = [];        for(var pIdx = 0; pIdx < paths.length; pIdx++){            var path = paths[pIdx];            var vecs = [];            Vectors[pIdx] = vecs;            var points = path.entirePath;            for(var i = 0; i < points.length; i++){                var point = points[i];                var vec;                if(point.length == 3){                        vec = [                            Vector3D(point[0][0], point[0][1],1),                            Vector3D(point[1][0], point[1][1],1),                            Vector3D(point[2][0], point[2][1],1)                        ];                }else{                       vec = Vector3D(point[0], point[1], 1);                }                vecs.push(vec);            }        }                return Vectors;}Poly.prototype.applyTransform = function(m3){        this.matrix = new Matrix3D(m3 * this.matrix);        this.calculateTransformedVectors();        this.transformNormal(this.matrix);}Poly.prototype.transformNormal = function(m3){        var invTrans = new Matrix3D(m3.minor(3,3).inverse().transpose());        var newNormal = invTrans * this.baseNormal;        this.normal = new Vector3D(newNormal[0][0], newNormal[1][0], newNormal[2][0]);}Poly.prototype.minZ = function(){    var z = 0;    var count = 0;    for(var i = 0; i < this.pathVectors[0].length; i++){            var vec = this.pathVectors[0][i];            if(vec instanceof Array) vec = vec[1];            z += vec.z;            count ++;    }    if(this.normal.z >= 0) z += 1000    return (z/count); }Poly.prototype.getCenter = function(){    var x = 0;    var y = 0;    var z =0;    var total = 0;        for(var i = 0; i < this.pathVectors[0].length; i++){            var vec = this.pathVectors[0][i];            if(vec instanceof Array) vec = vec[1];            x += vec.x;            y += vec.y;            z += vec.z;            total++;        }    return new Vector3D(x/total, y/total, z/total);}Poly.prototype.calculateNormal = function(){        var v1 = this.pathVectors[0][0];        var v2 = this.pathVectors[0][1];        var v3 = this.pathVectors[0][2];        if(v1 instanceof Array) v1 = v1[1];        if(v2 instanceof Array) v2 = v2[1];        if(v3 instanceof Array) v3 = v3[1];                var VectorU = v2 - v1;        var VectorV = v3 - v1;                var NormalX = VectorU.y * VectorV.z - VectorU.z * VectorV.y;        var NormalY = VectorU.z * VectorV.x - VectorU.x * VectorV.z;        var NormalZ = VectorU.x * VectorV.y - VectorU.y * VectorV.x;         return new Vector3D(NormalX, NormalY, NormalZ);}Poly.prototype.getShapeFromVectors = function(){        var shape = document.polygons.add();        shape.strokeWeight = 0;        shape.properties = {fillColor:"Black"};        for(var pIdx = 0; pIdx < this.vectors.length; pIdx++){                var pathList = this.vectors[pIdx];                var path = [];                var pathItem = shape.paths.item(pIdx);                if(!pathItem.isValid)                    var pathItem = shape.paths.add();                for(var i = 0; i < pathList.length; i++){                    var vec = pathList[i];                    if(vec instanceof Array){                        path.push([[vec[0].x, vec[0].y],[vec[1].x, vec[1].y],[vec[2].x, vec[2].y]]);                    }else{                        path.push([vec.x, vec.y]);                    }                }                       pathItem.entirePath = path;        }        return shape;}Poly.prototype.calculateTransformedVectors = function(){        this.pathVectors = [];        var vec                 for(var j = 0; j < this.vectors.length; j++){                var pathVecs = this.vectors[j];                var path = [];                this.pathVectors.push(path);                for(var i = 0; i < pathVecs.length; i++){                                        var baseVec = pathVecs[i];                    if(baseVec instanceof Array){                        vec = [baseVec[0].apply3DMatrix(this.matrix), baseVec[1].apply3DMatrix(this.matrix), baseVec[2].apply3DMatrix(this.matrix)]                    }else{                        vec = baseVec.apply3DMatrix(this.matrix);                    }                    path.push(vec);                }        } }Poly.prototype.setShapePath = function(){        var Xc, yC, zC;        var pageBounds =app.activeWindow.activePage.bounds;        xC = pageBounds[3]/2;        yC = pageBounds[2]/2;        zC = -1;                for(var pIdx = 0; pIdx < this.pathVectors.length; pIdx++){                var pathList = this.pathVectors[pIdx];                var path = [];                var pathItem = this.shape.paths.item(pIdx);                if(!pathItem.isValid)                    var pathItem = this.shape.paths.add();                                pathItem.pathType = PathType.CLOSED_PATH;                for(var i = 0; i < pathList.length; i++){                    var vector = pathList[i];                    if(vector instanceof Array){                         path.push([                            this.getPerspectivePoint (vector[0].x, vector[0].y, vector[0].z, xC, yC, zC),                            this.getPerspectivePoint (vector[1].x, vector[1].y, vector[1].z, xC, yC, zC),                            this.getPerspectivePoint (vector[2].x, vector[2].y, vector[2].z, xC, yC, zC),                         ]);                    }else{                         path.push(this.getPerspectivePoint(vector.x, vector.y, vector.z, xC, yC, zC));                    }                }                pathItem.entirePath = path;            }}Poly.prototype.getPerspectivePoint = function(x, y, z, xC, yC, zC){        var diffX = x - xC;        var diffY = y - yC;        var percent = 1-(z/300);        var pX = (x - xC) * percent + xC;        var pY = (y - yC)* percent + yC;        if(Config.PERSPECTIVE){             return [pX, pY];        }else{            return [x, y];        }}Poly.prototype.drawLine = function(){        var center = this.getCenter();        var normal = [this.normal.x + center.x, this.normal.y +center.y]        var line = document.polygons.add();        line.strokeColor = col(255,0,0);        line.strokeWeight = 0.05;        line.paths.firstItem().entirePath = [[center.x, center.y],[normal[0], normal[1]]];        this.line = line;}Poly.prototype.draw = function(){           this.setShapePath();       if(Config.SHOW_NORMALS){            if(this.line && this.line.isValid){                this.line.remove();            }            this.drawLine();       }       if(Config.CULL_BACKFACES){        this.shape.visible = this.normal.z <= 0;       }      }