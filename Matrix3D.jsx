#include Matrix.jsx/** * 3D Matrix to represent 3D affine transforms. Is automatically converted to a 4x4 matrix if necessary * to support perspective. * @return {[type]} [description] */Matrix3D = function(){    if(arguments[0] instanceof Matrix){        var asMatrix = arguments[0];        return new Matrix3D(asMatrix.toArray());    }    if ((this.constructor.name != "Matrix") ) {        return new Matrix3D(Array.prototype.slice.call(arguments));    }    Matrix.apply(this, Array.prototype.slice.call(arguments));    if(this.rows != this.columns){        throw new Error("Error: a 3D Matrix must be square");    }    if(this.rows != 3 && this.rows != 4){        throw new Error("Error: a 3D Matrix must have a size of either 3 or 4");    }    if(this.rows == 3){        this.columns = this.rows = 4;        var row = 3;        var column = 0;        this[row] = [];        for(; column < this.columns;column ++){            this[row][column] = 0;        }        var row = 0;        var column = 3;        for(; row < this.rows;row ++){            this[row][column] = 0;        }        this[3][3] = 1;    }    return this;}Matrix3D.prototype = new Matrix(true);/** * Return this matrix scaled by x, y * @param  {Float} x Amount to scale x dimensions * @param  {Float} y Amount to scale y dimensions * @return {Matrix3D}   Scaled Matrix */Matrix3D.prototype.scale = function(x, y, z){  var result = new Matrix3D(    [x, 0, 0],    [0, y, 0],    [0, 0, z]) * this;  return Matrix3D(result);}/** * Return this matrix around z rotated by delta degrees * @param  {Float} delta Degrees to rotate * @return {Matrix3D}       Rotated Matrix. */Matrix3D.prototype.rotate_z = function(delta){  delta = delta/(180/Math.PI)  var sinth = Math.sin(delta);  var costh = Math.cos(delta);  var rotated = new Matrix3D(    [costh, -sinth, 0],    [sinth, costh,  0],    [0, 0, 1]);  return Matrix3D(rotated * this);}/** * Return this matrix rotated around x by delta degrees * @param  {Float} delta Degrees to rotate * @return {Matrix3D}       Rotated Matrix. */Matrix3D.prototype.rotate_x = function(delta){  delta = delta/(180/Math.PI)  var sinth = Math.sin(delta);  var costh = Math.cos(delta);  var rotated = new Matrix3D(    [1.0, 0.0,    0.0],    [0.0, costh, -sinth],    [0.0, sinth, costh]);  return Matrix3D(rotated * this);}/** * Return this matrix rotated around y by delta degrees * @param  {Float} delta Degrees to rotate * @return {Matrix3D}       Rotated Matrix. */Matrix3D.prototype.rotate_y = function(delta){  delta = delta/(180/Math.PI)  var sinth = Math.sin(delta);  var costh = Math.cos(delta);  var rotated = new Matrix3D(    [costh,  0.0, sinth],    [0.0,    1.0, 0.0],    [-sinth, 0.0, costh]);  return Matrix3D(rotated * this);}  /** * Return this matrix translated by x, y * @param  {Float} x Delta x * @param  {Float} y Delta Y * @return {Matrix3D}   Translated Matrix */Matrix3D.prototype.translate = function(x, y, z){  var trans = new Matrix3D(    [1, 0, 0, x],    [0, 1, 0, y],    [0, 0, 1, z],    [0, 0, 0, 1]);  return Matrix3D(trans * this);}/** * Return this matrix sheared by x, y * @param  {Float} x Delta x * @param  {Float} y Delta y * @return {Matrix3D}   Sheared Matrix */Matrix3D.prototype.shear = function(x, y){  var shear = new Matrix3D(    [1, x, 0],    [y, 1, 0],    [0, 0, 1]);  return shear * this;}Matrix3D.identity = function(){        return new Matrix3D([1,0,0],[0,1,0],[0,0,1]);}